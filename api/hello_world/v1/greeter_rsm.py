# yapf: disable
# isort: skip_file

# Standard imports.
import grpc
import traceback
import uuid
import resemble.aio.state_managers
from abc import abstractmethod
from datetime import datetime, timedelta
from google.protobuf import any_pb2
from google.protobuf.descriptor import FileDescriptor
from google.protobuf.message import Message
from google.rpc import code_pb2, status_pb2
from grpc_status import rpc_status
from resemble.aio.contexts import (
    Context,
    ReaderContext,
    TransactionContext,
    WriterContext,
)
from resemble.aio.errors import Aborted
from resemble.aio.headers import Headers
from resemble.aio.idempotency import IdempotencyManager, Idempotency
from resemble.aio.internals.channel_manager import _ChannelManager
from resemble.aio.internals.middleware import Middleware
from resemble.aio.internals.tasks_cache import TasksCache
from resemble.aio.internals.tasks_dispatcher import TasksDispatcher
from resemble.aio.headers import Headers
from resemble.aio.servicers import Servicer, Serviceable
from resemble.aio.state_managers import Effects, StateManager
from resemble.aio.stubs import Stub
from resemble.aio.tasks import TaskEffect
from resemble.aio.types import ActorId, assert_type, GrpcMetadata, ServiceName
from resemble.aio.workflows import Workflow
from typing import (
    AsyncIterable,
    AsyncIterator,
    Awaitable,
    Callable,
    Optional,
    TypeAlias,
    Union,
)

# User defined or referenced imports.
import hello_world.v1.greeter_pb2
import hello_world.v1.greeter_pb2_grpc
import resemble.v1alpha1.options_pb2
# Additionally re-export all messages from the pb2 module.
from hello_world.v1.greeter_pb2 import (
    GreeterState,
    GreetingsRequest,
    GreetingsResponse,
    GreetRequest,
    GreetResponse,
)


def MakeLegacyGrpcServiceable(
    # A legacy gRPC servicer type can't be more specific than `type`,
    # because legacy gRPC servicers (as generated by the gRPC `protoc`
    # plugin) do not share any common base class other than `object`.
    servicer_type: type
) -> Serviceable:
    raise ValueError(f"Unknown legacy gRPC servicer type '{servicer_type}'")


class GreeterServicerMiddleware(Middleware):

    def __init__(
        self,
        servicer: 'GreeterServicer',
        state_manager: StateManager,
        channel_manager: _ChannelManager,
        tasks_cache: TasksCache,
    ):
        super().__init__(
            channel_manager=channel_manager,
            service_name='hello_world.v1.Greeter',
        )

        self._servicer = servicer
        self._state_manager = state_manager
        self.tasks_dispatcher = TasksDispatcher(self.dispatch, tasks_cache)

        # Store the type of each method's request so that stored requests can be
        # deserialized into the correct type.
        self.request_type_by_method_name: dict[str, type[Message]] = {
            'Greetings': hello_world.v1.greeter_pb2.GreetingsRequest,
            'Greet': hello_world.v1.greeter_pb2.GreetRequest,
        }

    def add_to_server(self, server: grpc.aio.Server) -> None:
        hello_world.v1.greeter_pb2_grpc.add_GreeterServicer_to_server(
            self, server
        )

    async def react(
        self, actor_id: ActorId, method: str, request_bytes: bytes
    ) -> AsyncIterator[Message]:
        """Returns the response of calling 'method' given a message
        deserialized from the provided 'request_bytes' for each state
        update that creates a different response.

        NOTE: only unary reader methods are supported."""
        # Need to define these up here since we can only do that once.
        last_response: Optional[Message] = None
        idempotency_keys: list[uuid.UUID] = []
        if 'Greetings' == method:
            context = self.create_context(
                headers=Headers(
                    service_name='hello_world.v1.Greeter',
                    actor_id=actor_id,
                ),
                context_type=ReaderContext,
            )

            request = hello_world.v1.greeter_pb2.GreetingsRequest()
            request.ParseFromString(request_bytes)

            async with self._state_manager.streaming_reader_idempotency_key(
                context, self._servicer.__state_type__
            ) as states:
                async for (state, idempotency_key) in states:
                    response = await self._servicer.Greetings(
                        context, state, request
                    )
                    if idempotency_key is not None:
                        idempotency_keys.append(idempotency_key)
                    if last_response != response:
                        yield (response, idempotency_keys)
                        last_response = response
                        idempotency_keys.clear()
        elif 'Greet' == method:
            # Invariant here is that users should not have called this
            # directly but only through code generated React
            # components which should not have been generated except
            # for valid method candidates.
            raise ValueError(f"Method '{method}' is invalid")
            yield  # Necessary for type checking.
        else:
            raise RuntimeError(f"Method '{method}' not found")
            yield  # Necessary for type checking.

    async def dispatch(
        self, task: TaskEffect, *, only_validate: bool = False
    ) -> Message:
        """Dispatches the tasks to execute unless 'only_validate' is set to
        true, in which case just ensures that the task actually exists.
        Note that this function will be called *by* tasks_dispatcher; it will
        not itself call into tasks_dispatcher."""
        # Need to forward declare context since we set it to different
        # types depending on if the task is a reader or a writer.
        context: Context


        # There are no tasks for this service.
        start_or_validate = "start" if not only_validate else "validate"
        raise RuntimeError(
            f"Attempted to {start_or_validate} task '{task.method_name}' "
            f"on 'Greeter' which does not exist"
        )

    # Greeter specific methods:
    async def Greetings(
        self,
        request: hello_world.v1.greeter_pb2.GreetingsRequest,
        grpc_context: grpc.aio.ServicerContext,
    ) -> hello_world.v1.greeter_pb2.GreetingsResponse:

        # Need to define 'transaction' in case we fail to parse headers, return
        # early after checking idempotency, or if 'transactionally()' raises.
        transaction: Optional[StateManager.Transaction] = None

        try:
            context: ReaderContext = self.create_context_from_grpc(
                grpc_context=grpc_context, context_type=ReaderContext
            )


            async with self._state_manager.transactionally(
                context, self.tasks_dispatcher
            ) as transaction:
                if transaction is not None:
                    context.participants.add(
                        self._servicer.__service_name__, context.actor_id
                    )

                async with self._state_manager.reader(
                    context, self._servicer.__state_type__
                ) as state:
                    response = await self._servicer.Greetings(
                        context,
                        state,
                        request
                    )
                    if transaction is not None:
                        # We need the transaction to be stored _before_
                        # returning a response to the user otherwise they
                        # may read two different states if we crash.
                        await self._state_manager.transaction_participant_store(
                            transaction
                        )
                    return response
        except BaseException as exception:
            # Print the exception stack trace for easier debugging. Note
            # that we don't include the stack trace in an error message
            # for the same reason that gRPC doesn't do so by default,
            # see https://github.com/grpc/grpc/issues/14897, but since this
            # should only get logged on the server side it is safe.
            traceback.print_exc()

            # Re-raise the exception for gRPC to handle!
            raise
        finally:
            if transaction is not None:
                # Propagate transaction participants.
                #
                # NOTE: we'll want to propagate participants if we're
                # in a transaction method once we support nested
                # transactions, but for now we only need to propagate
                # participants when we're not in a transaction method.
                if not isinstance(context, TransactionContext):
                    grpc_context.set_trailing_metadata(
                        grpc_context.trailing_metadata() +
                        context.participants.to_grpc_metadata()
                    )

    async def Greet(
        self,
        request: hello_world.v1.greeter_pb2.GreetRequest,
        grpc_context: grpc.aio.ServicerContext,
    ) -> hello_world.v1.greeter_pb2.GreetResponse:

        # Need to define 'transaction' in case we fail to parse headers, return
        # early after checking idempotency, or if 'transactionally()' raises.
        transaction: Optional[StateManager.Transaction] = None

        try:
            context: WriterContext = self.create_context_from_grpc(
                grpc_context=grpc_context, context_type=WriterContext
            )

            # Check if we already have performed this mutation!
            #
            # We do this _before_ calling 'transactionally()' because
            # if this call is for a transaction method _and_ we've
            # already performed the transaction then we don't want to
            # become a transaction participant (again) we just want to
            # return the transaction's response.
            response_bytes: Optional[
                bytes
            ] = self._state_manager.get_response_if_idempotent_mutation(
                context
            )

            if response_bytes is not None:
                response = hello_world.v1.greeter_pb2.GreetResponse()
                response.ParseFromString(response_bytes)
                return response

            async with self._state_manager.transactionally(
                context, self.tasks_dispatcher
            ) as transaction:
                if transaction is not None:
                    context.participants.add(
                        self._servicer.__service_name__, context.actor_id
                    )

                # TODO: this loads a `state` object even when we know we're calling a constructor,
                # in which case (by definition) there is no state. Can we (and is it worth
                # the effort to) change this call to avoid that overhead in that case?
                async with self._state_manager.writer(
                    context,
                    self._servicer.__state_type__,
                    transaction=transaction,
                    from_constructor=False,
                    requires_constructor=False
                ) as (state, writer):
                    effects = await self._servicer.Greet(
                        context,
                        state,
                        request
                    )

                    if effects.tasks is not None:
                        # NOTE: we validate tasks added as part of a
                        # transaction when we prepare.
                        if transaction is None:
                            await self.tasks_dispatcher.validate(
                                effects.tasks
                            )

                    await writer.complete(effects)

                    if effects.tasks is not None:
                        if transaction is None:
                            self.tasks_dispatcher.dispatch(effects.tasks)
                        else:
                            assert all(
                                task.task_id.service == transaction.service
                                for task in effects.tasks
                            ), 'Task service does not match transaction service'
                            transaction.tasks.extend(effects.tasks)

                    return effects.response
        except BaseException as exception:
            # Print the exception stack trace for easier debugging. Note
            # that we don't include the stack trace in an error message
            # for the same reason that gRPC doesn't do so by default,
            # see https://github.com/grpc/grpc/issues/14897, but since this
            # should only get logged on the server side it is safe.
            traceback.print_exc()

            # Re-raise the exception for gRPC to handle!
            raise
        finally:
            if transaction is not None:
                # Propagate transaction participants.
                #
                # NOTE: we'll want to propagate participants if we're
                # in a transaction method once we support nested
                # transactions, but for now we only need to propagate
                # participants when we're not in a transaction method.
                if not isinstance(context, TransactionContext):
                    grpc_context.set_trailing_metadata(
                        grpc_context.trailing_metadata() +
                        context.participants.to_grpc_metadata()
                    )


class _GreeterStub(Stub):

    def __init__(
        self,
        context_or_workflow: Context | Workflow,
        actor_id: ActorId,
    ):
        super().__init__(
            channel_manager=context_or_workflow.channel_manager,
            idempotency_manager=context_or_workflow,
            service_name='hello_world.v1.Greeter',
            actor_id=actor_id,
            context=(
                context_or_workflow
                if issubclass(type(context_or_workflow), Context)
                else None # type: ignore
            ),
        )

        channel = self._channel_manager.get_channel_for(
            GreeterServicer, actor_id
        )
        self._stub = hello_world.v1.greeter_pb2_grpc.GreeterStub(channel)


class GreeterReaderStub(_GreeterStub):

    def __init__(
        self,
        context_or_workflow: ReaderContext | WriterContext | TransactionContext | Workflow,
        actor_id: ActorId
    ):
        assert_type(
            context_or_workflow,
            [ReaderContext, WriterContext, TransactionContext, Workflow]
        )
        super().__init__(context_or_workflow, actor_id)

    # Greeter specific methods:
    async def Greetings(
        self,
        request: hello_world.v1.greeter_pb2.GreetingsRequest,
        *,
        metadata: Optional[GrpcMetadata] = None,
    ) -> hello_world.v1.greeter_pb2.GreetingsResponse:
        async with self._call(
            self._stub.Greetings,
            request,
            metadata=metadata,
        ) as call:
            return await call



class GreeterWriterStub(_GreeterStub):

    def __init__(
        self,
        context_or_workflow: TransactionContext | Workflow,
        actor_id: ActorId
    ):
        assert_type(context_or_workflow, [TransactionContext, Workflow])
        super().__init__(context_or_workflow, actor_id)

    # Greeter specific methods:
    async def Greetings(
        self,
        request: hello_world.v1.greeter_pb2.GreetingsRequest,
        *,
        metadata: Optional[GrpcMetadata] = None,
    ) -> hello_world.v1.greeter_pb2.GreetingsResponse:
        async with self._call(
            self._stub.Greetings,
            request,
            metadata=metadata,
        ) as call:
            return await call

    async def Greet(
        self,
        request: hello_world.v1.greeter_pb2.GreetRequest,
        idempotency: Optional[Idempotency] = None,
        *,
        metadata: Optional[GrpcMetadata] = None,
    ) -> hello_world.v1.greeter_pb2.GreetResponse:
        idempotency_key: Optional[str]
        with self._idempotency_manager.idempotently(
            service=self._headers.service_name,
            actor_id=self._headers.actor_id,
            method='Greet',
            request=request,
            metadata=metadata,
            idempotency=idempotency,
        ) as idempotency_key:
            async with self._call(
                self._stub.Greet,
                request,
                idempotency_key=idempotency_key,
                metadata=metadata,
            ) as call:
                return await call


class GreeterTransactionStub(_GreeterStub):

    def __init__(
        self,
        context_or_workflow: TransactionContext | Workflow,
        actor_id: ActorId
    ):
        assert_type(context_or_workflow, [TransactionContext, Workflow])
        super().__init__(context_or_workflow, actor_id)

    # Greeter specific methods:
    async def Greetings(
        self,
        request: hello_world.v1.greeter_pb2.GreetingsRequest,
        *,
        metadata: Optional[GrpcMetadata] = None,
    ) -> hello_world.v1.greeter_pb2.GreetingsResponse:
        async with self._call(
            self._stub.Greetings,
            request,
            metadata=metadata,
        ) as call:
            return await call

    async def Greet(
        self,
        request: hello_world.v1.greeter_pb2.GreetRequest,
        idempotency: Optional[Idempotency] = None,
        *,
        metadata: Optional[GrpcMetadata] = None,
    ) -> hello_world.v1.greeter_pb2.GreetResponse:
        idempotency_key: Optional[str]
        with self._idempotency_manager.idempotently(
            service=self._headers.service_name,
            actor_id=self._headers.actor_id,
            method='Greet',
            request=request,
            metadata=metadata,
            idempotency=idempotency,
        ) as idempotency_key:
            async with self._call(
                self._stub.Greet,
                request,
                idempotency_key=idempotency_key,
                metadata=metadata,
            ) as call:
                return await call


class GreeterWorkflowStub(_GreeterStub):

    def __init__(
        self,
        workflow: Workflow,
        actor_id: ActorId
    ):
        assert_type(workflow, [Workflow])
        super().__init__(workflow, actor_id)

    # Greeter specific methods:
    async def Greetings(
        self,
        request: hello_world.v1.greeter_pb2.GreetingsRequest,
        *,
        metadata: Optional[GrpcMetadata] = None,
    ) -> hello_world.v1.greeter_pb2.GreetingsResponse:
        async with self._call(
            self._stub.Greetings,
            request,
            metadata=metadata,
        ) as call:
            return await call

    async def Greet(
        self,
        request: hello_world.v1.greeter_pb2.GreetRequest,
        idempotency: Optional[Idempotency] = None,
        *,
        metadata: Optional[GrpcMetadata] = None,
    ) -> hello_world.v1.greeter_pb2.GreetResponse:
        idempotency_key: Optional[str]
        with self._idempotency_manager.idempotently(
            service=self._headers.service_name,
            actor_id=self._headers.actor_id,
            method='Greet',
            request=request,
            metadata=metadata,
            idempotency=idempotency,
        ) as idempotency_key:
            async with self._call(
                self._stub.Greet,
                request,
                idempotency_key=idempotency_key,
                metadata=metadata,
            ) as call:
                return await call


class GreeterTasksStub(_GreeterStub):

    def __init__(self, context: WriterContext, actor_id: ActorId):
        assert_type(context, [WriterContext])
        super().__init__(context, actor_id)

    # Greeter specific methods:



class GreeterServicer(Servicer):
    __service_name__ = 'hello_world.v1.Greeter'
    __file_descriptor__ = hello_world.v1.greeter_pb2.DESCRIPTOR
    __state_type__: type[Message] = hello_world.v1.greeter_pb2.GreeterState

    def __init__(self):
        # NOTE: need to hold on to the middleware so we can do inline
        # writes (see 'self.write(...)').
        #
        # Because '_middleware' is not really private this does mean
        # users may do possibly dangerous things, but this is no more
        # likely given they could have already overridden
        # 'create_middleware()'.
        self._middleware: Optional[GreeterServicerMiddleware] = None

    def create_middleware(
        self,
        state_manager: StateManager,
        channel_manager: _ChannelManager,
        tasks_cache: TasksCache,
    ) -> GreeterServicerMiddleware:
        self._middleware = GreeterServicerMiddleware(
            self, state_manager, channel_manager, tasks_cache
        )
        return self._middleware

    def instance(self, context: Context):
        """Returns an instance of the service for the specified context."""
        # TODO(benh): improve this to not require passing 'context',
        # e.g., by storing 'context' in a contextvar.
        return Greeter(context.actor_id)

    class Tasks:
        def __init__(self, when: Optional[datetime | timedelta] = None):
            self._when = when

        # Greeter specific methods:

    def schedule(
        self,
        when: Optional[datetime | timedelta] = None,
    ):
        return self.Tasks(when)

    class Effects(resemble.aio.state_managers.Effects):
        def __init__(
            self,
            *,
            state: hello_world.v1.greeter_pb2.GreeterState,
            response: Optional[Message] = None,
            tasks: Optional[list[TaskEffect]] = None
        ):
            assert_type(state, [hello_world.v1.greeter_pb2.GreeterState])

            super().__init__(state=state, response=response, tasks=tasks)


    class GreetEffects(Effects):
        def __init__(
            self,
            *,
            state: hello_world.v1.greeter_pb2.GreeterState,
            response: hello_world.v1.greeter_pb2.GreetResponse,
            tasks: Optional[list[TaskEffect]] = None
        ):
            assert_type(state, [hello_world.v1.greeter_pb2.GreeterState])
            assert_type(response, [hello_world.v1.greeter_pb2.GreetResponse])

            super().__init__(state=state, response=response, tasks=tasks)



    async def read(
        self, context: TransactionContext
    ) -> hello_world.v1.greeter_pb2.GreeterState:
        """Read the current state within a transaction."""
        assert_type(context, [TransactionContext])

        if self._middleware is None:
            raise RuntimeError(
                'Resemble middleware was not created; '
                'are you using this class without Resemble?'
            )

        return await self._middleware._state_manager.read(
            context, self.__state_type__
        )

    async def write(
        self,
        context: TransactionContext,
        f: Callable[[WriterContext, Message], Awaitable[Effects]],
    ):
        """Perform an "inline write" within a transaction."""
        assert_type(context, [TransactionContext])

        if self._middleware is None:
            raise RuntimeError(
                'Resemble middleware was not created; '
                'are you using this class without Resemble?'
            )

        writer_context: WriterContext = self._middleware.create_context(
            headers=Headers(
                service_name=self.__service_name__,
                actor_id=context.actor_id,
                transaction_id=context.transaction_id,
                transaction_coordinator_service=context
                .transaction_coordinator_service,
                transaction_coordinator_actor_id=context
                .transaction_coordinator_actor_id
            ),
            context_type=WriterContext,
        )

        async with self._middleware._state_manager.transactionally(
            writer_context, self._middleware.tasks_dispatcher
        ) as transaction:
            assert transaction is not None
            async with self._middleware._state_manager.writer(
                writer_context, self.__state_type__, transaction=transaction
            ) as (state, writer):
                effects: GreeterServicer.Effects = await f(
                    writer_context, state
                )

                assert_type(effects, [GreeterServicer.Effects])

                # NOTE: we validate tasks added as part of a
                # transaction when we prepare.

                await writer.complete(effects)

                if effects.tasks is not None:
                    assert all(
                        task.task_id.service == transaction.service
                        for task in effects.tasks
                    ), 'Task service does not match transaction service'
                    transaction.tasks.extend(effects.tasks)

                return effects.response  # May be 'None'.

    # Greeter specific methods:
    @abstractmethod
    async def Greetings(
        self,
        context: ReaderContext,
        state: hello_world.v1.greeter_pb2.GreeterState,
        request: hello_world.v1.greeter_pb2.GreetingsRequest,
    ) -> hello_world.v1.greeter_pb2.GreetingsResponse:
        raise NotImplementedError

    @abstractmethod
    async def Greet(
        self,
        context: WriterContext,
        state: hello_world.v1.greeter_pb2.GreeterState,
        request: hello_world.v1.greeter_pb2.GreetRequest,
    ) -> GreetEffects:
        raise NotImplementedError


class Greeter:

    Interface: TypeAlias = GreeterServicer

    Effects: TypeAlias = GreeterServicer.Effects


    GreetEffects: TypeAlias = Interface.GreetEffects


    def __init__(self, id: str):
        self._id = id
        self._reader_stub: Optional[GreeterReaderStub] = None
        self._writer_stub: Optional[GreeterWriterStub] = None
        self._workflow_stub: Optional[GreeterWorkflowStub] = None

    def reader(
        self,
        context: ReaderContext | WriterContext | TransactionContext | Workflow,
    ) -> GreeterReaderStub:
        if self._reader_stub is None:
            self._reader_stub = GreeterReaderStub(
                context, self._id
            )
        assert self._reader_stub is not None
        assert self._reader_stub._idempotency_manager == context
        return self._reader_stub

    def writer(
        self,
        context: TransactionContext | Workflow,
    ) -> GreeterWriterStub:
        if self._writer_stub is None:
            self._writer_stub = GreeterWriterStub(
                context, self._id
            )
        assert self._writer_stub is not None
        assert self._writer_stub._idempotency_manager == context
        return self._writer_stub

    def workflow(
        self,
        workflow: Workflow,
    ) -> GreeterWorkflowStub:
        if self._workflow_stub is None:
            self._workflow_stub = GreeterWorkflowStub(
                workflow, self._id
            )
        assert self._workflow_stub is not None
        assert self._workflow_stub._idempotency_manager == workflow
        return self._workflow_stub

    # Greeter specific methods:
    async def Greetings(
        self,
        context: ReaderContext | WriterContext | TransactionContext | Workflow,
        rsm_metadata: Optional[GrpcMetadata] = None,
    ) -> hello_world.v1.greeter_pb2.GreetingsResponse:
        request = hello_world.v1.greeter_pb2.GreetingsRequest(
        )
        return await self.reader(context).Greetings(
            request,
            metadata=rsm_metadata,
        )

    async def Greet(
        self,
        rsm_context_or_workflow: TransactionContext | Workflow,
        rsm_idempotency: Optional[Idempotency] = None,
        rsm_metadata: Optional[GrpcMetadata] = None,
        *,
        greeting: Optional[str] = None,
    ) -> hello_world.v1.greeter_pb2.GreetResponse:
        request = hello_world.v1.greeter_pb2.GreetRequest(
            greeting=greeting,
        )
        return await self.writer(rsm_context_or_workflow).Greet(
            request,
            rsm_idempotency,
            metadata=rsm_metadata,
        )


# yapf: enable
